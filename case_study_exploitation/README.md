# TOP - based Exploitation

*Throw Oriented Programming* is a novel exploitation technique involving Android bytecode. This case study shows a *PoC* exploit running *NOP* gadgets using a `packed-switch` dispatcher. As finding native vulnerabilities in an app is an involved process, and as of writing we know of no app with *sufficient vulnerabilities* to enable *TOP*, [*EEVA*](https://github.com/fkie-cad/eeva) is used to create such a vulnerable app.

This *PoC* only triggers a *NOP* chain to highlight that *TOP* gadgets are chainable using the `throw` bytecode instruction. We leave constructing more sophisticated payloads as future work, as e.g. popping a shell in an app intentionally designed for this *PoC* does not seem fruitful.

## Highlevel Exploit Explanation

The vulnerable module in *EEVA* provides *Read - What - Where* and *Write - What - Where* conditions in that order. Leaking the base address of `libart.so` is not part of the module and must be provided manually. Also, `libart.so` and `base.vdex` files are required for symbol resolution and *TOP* chain generation, respectively.

Exploitation roughly follows below steps.

1. Find base address of `base.vdex`. This assumes that
	1. a `base.vdex` file exists in the process image, and
	2. the `base.vdex` file contains `.dex` files, whose bytecode is (partially) interpreted at runtime.
2. Setting up and performing patches generated with [*Topper*](https://github.com/fkie-cad/Topper). This triggers execution of the *TOP* chain generated with *Topper*.

All `client` - related statements are required to communicate with the vulnerable module in *EEVA*. `input` is used to pause execution, which allows attaching e.g. *gdbserver*.

## Detailed Exploit Explanation

Patch generation is not explained here, as it is simply an application of *Topper*.

There may exist many ways for finding the address of an existing `base.vdex` file. One particular idea is to parse the [`OatFileManager::oat_files_`](https://cs.android.com/android/platform/superproject/+/android-13.0.0_r16:art/runtime/oat_file_manager.h;l=160;drc=c25a9f9c2a3637e4e1f8de182ff321748601d5ac) variable, which is [part](https://cs.android.com/android/platform/superproject/+/android-13.0.0_r16:art/runtime/runtime.h;l=1363;drc=e7e026bc67750757d85286ef3990b07e20c251a0) of the unique [`Runtime::instance_`](https://cs.android.com/android/platform/superproject/+/android-13.0.0_r16:art/runtime/runtime.h;l=1132;drc=e7e026bc67750757d85286ef3990b07e20c251a0). `Runtime::instance_` is a static, uninitialized variable and thus available in the `.bss` section of `libart.so`. `OatFileManager::oat_files_` is an `std::set`, which turns out to be implemented using a tree structure. Thus, `get_vdex_base` in the exploit mainly traverses that tree while parsing [`OatFile`](https://cs.android.com/android/platform/superproject/+/android-13.0.0_r16:art/runtime/oat_file.h;l=95;drc=69a87e30730d0c6e6e5974fd2bd001f77fffed5e) objects stored in that tree. As identified via reverse engineering and debugging, there exists a node named "base.odex", which references `base.vdex`. This approach for finding `base.vdex` emerged from searching for all usages of the base address of `base.vdex` using [*gef*](https://github.com/hugsy/gef). Afterwards, the main challenge was to identify the structures that referenced `base.vdex`, one of which turned out to be `OatFileManager::oat_files_`.

## Notes on practicality

In its original form, *TOP* makes three major assumptions:
1. *Write - What - Where* condition: Allows an attacker to write arbitrary data (qwords) to arbitrary memory locations. This vulnerability may be invoked multiple times.
2. *Read - What - Where* condition: Allows an attacker to read arbitrary data (qwords) from arbitrary memory locations. This vulnerability may be invoked multiple times.
3. *libart.so leak*: Information leak of a known component of `libart.so`, i.e. the heart of the *Android Runtime*.

Observe that Android forks apps from `zygote`, implying that the third assumption may be "easier" to fulfill on Android than on systems that do not use fork to run apps. E.g. if an attacker tricked a victim into installing a malicious app, is now looking to escalate privileges and knows of an installed app that provides assumptions 1 and 2, then the malicious app suffices to fulfill assumption 3. This stems from the fact that an app has full control over its own process, e.g. by using *JNI* (see [obfuscation case study](https://github.com/fkie-cad/TOP-Android/blob/main/case_study_obfuscation/code/PoCTOPObfuscation/app/src/main/cpp/patch.c#L179) for an example of how to use *JNI* to get `libart.so`).

However, we do not claim that *TOP* is applicable to the majority of native app vulnerabilities. *TOP* is a niche exploitation technique, whose main purpose is to highlight that **bytecode must be as well protected as native code**.
