# TOP - based Obfuscation

Not only is *TOP* a novel bytecode - based exploitation technique, but it can also be used to obfuscate the behaviour of an app. To that end, we created a sample app with the following properties:
1. *TOP* is used to hide an in-place array xor-decryption using a secret, but fixed key byte.
2. All assumptions made by *TOP* are easily fulfilled, because we fully control our own process.
3. In order to keep this app small, *TOP* gadgets are "manually" injected, but hidden using a random byte table generated by `generate_table.py`. A particular table consists of $2^{16}$ bytes. Injected gadgets are placed at random offsets in that table. The rest of the table is filled with random bytes.

Analysing the Java side of this PoC, one would expect an output of `Hello World!`:
```java
protected void onCreate(Bundle savedInstanceState) {
	...
	TextView tv = new TextView(this);
	setup();
	tv.setText(new String(Test.getText()));
	setContentView(tv);
}
...
public class Test {
    public Test() {

    }

    public static final char[] getText() {
        return "Hello World!".toCharArray();
    }
}
```

However, the app displays `flag` (might be an interesting reversing CTF challenge). Obviously, this change comes from `setup`, which hijacks `Test::getText` through manipulation of its corresponding `ArtMethod`. `Test::getText` returns a `char[]` for reasons of simplification. As `generate_table.py` can be adjusted to provide any dex bytecode program and its offsets, one may create arbitrary programs. Even conditional branching is possible by modifying the virtual program counter vreg (`v1` for this PoC).

It may be important to call `move-exception vAA` before returning to actual Java code, because *TOP* keeps passing on the same exception object (through `v0` in this PoC), but never "claims" to handle it. We did **not** verify this, but the fact that the PoC did not crash when calling `move-exception` convinced us to keep it.

## WARNING

Because we simply placed the random table in a header file (`table.h`) instead of outsourcing it into a file or generating the table at runtime, *Android Studio* may be overwhelmed and thus run slowly or crash. Similarily, It is not recommended to open `table.h` in e.g. your browser.

There are two `.apk` files built in release mode and signed with a custom key for easy installation through `adb install <path to>/app-release.apk`.

## Conclusion

Notice that it is possible to write malware using only *TOP*. Taking this PoC into account, it seems hard to understand software that abuses highly Android - specific subtleties to hijack its own control flow. Although redirecting an `ArtMethod` is not complicated, the more is *TOP*. This highlights the need for not only protecting native code, but also bytecode.
